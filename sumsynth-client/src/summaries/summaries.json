{
    "under": {
        "abs": "fn abs(x: int32) := {\n    locals: (ret: int32)\n    pre: x < 0\n    post: ret == -x;\n\n    locals: (ret: int32)\n    pre: x >= 0\n    post: ret == x\n}",
        "bzero": "fn bzero(s: ^T, n: uint32) := {\n    locals: (lst: list<char>)\n    pre: zeroes(n; lst)\n    pre_mut: allocd(s, n) \n    post: memw(s; lst)\n}\n\npred zeroes(n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] n > 0 <*> c == '\\0' <*> lst == cons(c, lst_tl) <*> zeroes(n - 1; lst_tl)\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "calloc": "fn calloc(nitems: uint32, size: uint32) := {\n    locals: (lst: list<char>, retval: ^T, ret: ^T)\n    pre: zeroes(nitems * size; lst)\n    post_new: allocd(retval, nitems * size)\n    post: memw(retval; lst) <*> ret == retval\n}\n\npred zeroes(n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] n > 0 <*> c == '\\0' <*> lst == cons(c, lst_tl) <*> zeroes(n - 1; lst_tl)\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "free": "fn free(src: ^T) := {\n    locals: (n: int32)\n    pre: nallocd(src; n)\n    pre_vanish: allocd(src, n)\n    post: emp\n}",
        "isalnum": "fn isalnum(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isalnum(c; b)\n    post: ret == b\n}\n\npred isalnum(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 == 0 && b2 == 0) <*> b == 0;\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 != 0 || b2 != 0) <*> b == 1\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isalpha": "fn isalpha(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isalpha(c; b)\n    post: ret == b\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}",
        "iscntrl": "fn iscntrl(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: iscntrl(c; b)\n    post: ret == b\n}\n\npred iscntrl(c: int32; b: int32) := {\n    (c == 127 || (c >= 0 && c <= 31)) <*> b == 1;\n    (c != 127 && (c < 0 || c > 31)) <*> b == 0\n}",
        "isdigit": "fn isdigit(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isdigit(c; b)\n    post: ret == b\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isgraph": "fn isgraph(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isgraph(c; b)\n    post: ret == b\n}\n\npred isgraph(c: int32; b: int32) := {\n    exists [b1: int32] isprint(c; b1) <*> (b1 == 0 || c == ' ') <*> b == 0;\n    exists [b1: int32] isprint(c; b1) <*> (b1 != 0 && c != ' ') <*> b == 1\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}",
        "islower": "fn islower(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: islower(c; b)\n    post: ret == b\n}\n\npred islower(c: int32; b: int32) := {\n    (c >= 'a' && c <= 'z') <*> b == 1;\n    (c < 'a' || c > 'z') <*> b == 0\n}",
        "isprint": "fn isprint(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isprint(c; b)\n    post: ret == b\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}",
        "ispunct": "fn ispunct(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: ispunct(c; b)\n    post: ret == b\n}\n\npred ispunct(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32, b3: int32] isprint(c; b1) <*> isspace(c; b2) <*> isalnum(c; b3) <*> (b1 != 0 && b2 == 0 && b3 == 0) <*> b == 1;\n    exists [b1: int32, b2: int32, b3: int32] isprint(c; b1) <*> isspace(c; b2) <*> isalnum(c; b3) <*> (b1 == 0 || b2 != 0 || b3 != 0) <*> b == 0\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}\n\npred isspace(c: int32; b: int32) := {\n    (c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r' || c == ' ') <*> b == 1;\n    (c != '\\t' && c != '\\n' && c != '\\v' && c != '\\f' && c != '\\r' && c != ' ') <*> b == 0\n}\n\npred isalnum(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 == 0 && b2 == 0) <*> b == 0;\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 != 0 || b2 != 0) <*> b == 1\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isspace": "fn isspace(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isspace(c; b)\n    post: ret == b\n}\n\npred isspace(c: int32; b: int32) := {\n    (c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r' || c == ' ') <*> b == 1;\n    (c != '\\t' && c != '\\n' && c != '\\v' && c != '\\f' && c != '\\r' && c != ' ') <*> b == 0\n}",
        "isupper": "fn isupper(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isupper(c; b)\n    post: ret == b\n}\n\npred isupper(c: int32; b: int32) := {\n    (c >= 'A' && c <= 'Z') <*> b == 1;\n    (c < 'A' || c > 'Z') <*> b == 0\n}",
        "isxdigit": "fn isxdigit(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isxdigit(c; b)\n    post: ret == b\n}\n\npred isxdigit(c: int32; b: int32) := {\n    exists [b1: int32] isdigit(c; b1) <*> (b1 != 0 || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) <*> b == 1;\n    exists [b1: int32] isdigit(c; b1) <*> (b1 == 0 && (c < 'a' || c > 'f') && (c < 'A' || c > 'F')) <*> b == 0\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "malloc": "fn malloc(n: uint32) := {\n    locals: (retval: ^T, ret: ^T)\n    pre: emp\n    post_new: allocd(retval, n)\n    post: ret == retval\n}",
        "memchr": "fn memchr(s: ^T, c: int32, n: uint32) := {\n    locals: (p: ^char, ret: ^T)\n    pre: memc(s, c, n; p)\n    post: ret == p\n}\n\npred memc(s: ^T, c: int32, n: uint32; p: ^T) := {\n    n == 0 <*> p == 0;\n    exists [c1: char] s -> c1 <*> n != 0 <*> c == c1 <*> p == s;\n    exists [c1: char] s -> c1 <*> n != 0 <*> c != c1 <*> memc(s + 1, c, n - 1; p)\n}",
        "memcmp": "fn memcmp(s1: ^T, s2: ^T, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: memd(s1, s2, n; b)\n    post: ret == b\n}\n\npred memd(s1: ^T, s2: ^T, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> c1 == c2 <*> memd(s1 + 1, s2 + 1, n - 1; b)\n}",
        "memcpy": "fn memcpy(dest: ^T, src: ^T, n: uint32) := {\n    locals: (lst_src: list<char>, ret: ^T)\n    pre: memseg(src, n; lst_src) \n    pre_mut: allocd(dest, n)\n    post: memw(dest; lst_src) <*> ret == dest\n}\n\npred memseg(s: ^char, n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memseg(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != [] <*> n > 0\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "memmove": "fn memmove(dest: ^T, src: ^T, n: uint32) := {\n    locals: (lst_src: list<char>, ret: ^T)\n    pre: memseg(src, n; lst_src) \n    pre_mut: allocd(dest, n)\n    post: memw(dest; lst_src) <*> ret == dest\n}\n\npred memseg(s: ^char, n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memseg(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != [] <*> n > 0\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "memset": "fn memset(str: ^T, c: int32, n: uint32) := {\n    locals: (lst: list<char>, ret: ^T)\n    pre: nbytes(c, n; lst)\n    pre_mut: allocd(str, n) \n    post: memw(str; lst) <*> ret == str\n}\n\npred nbytes(c: char, n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [lst_tl: list<char>] n > 0 <*> lst == cons(c, lst_tl) <*> nbytes(c, n - 1; lst_tl)\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "putchar": "fn putchar(c: int32) := {\n    locals: (ret: int32)\n    pre: emp\n    post: ret == c\n}",
        "puts": "fn puts(s: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: str(s; n)\n    post: ret == n + 1\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k)\n}",
        "strcasecmp": "fn strcasecmp(s1: ^char, s2: ^char) := {\n    locals: (b: int32, ret: int32)\n    pre: strcased(s1, s2; b)\n    post: ret == b\n}\n\npred strcased(s1: ^char, s2: ^char; b: int32) := {\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 != c4 <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 == c4 <*> strcased(s1 + 1, s2 + 1; b)\n}\n\npred tolower(c: char; c1: char) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A');\n    (c < 'A' || c > 'Z') <*> c1 == c\n}",
        "strcasencmp": "fn strcasencmp(s1: ^char, s2: ^char, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: strcasend(s1, s2, n; b)\n    post: ret == b\n}\n\npred strcasend(s1: ^char, s2: ^char, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 != c4 <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 == c4 <*> strcasend(s1 + 1, s2 + 1, n - 1; b)\n}\n\npred tolower(c: char; c1: char) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A');\n    (c < 'A' || c > 'Z') <*> c1 == c\n}",
        "strcat": "fn strcat(dest: ^char, src: ^char) := {\n    locals: (lst_src: list<char>, lst_dest: list<char>, n: int32, m: int32, ret: ^char)\n    pre: cstr(src; lst_src) <*> cstr(dest; lst_dest) <*> n == len(lst_src) <*> m == len(lst_dest) \n    pre_mut: allocd(dest + m, n + 1) \n    post: cstr(dest + m; lst_src) <*> ret == dest\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strchr": "fn strchr(s: ^char, c: int32) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strc(s, c; p)\n    post: ret == p\n}\n\npred strc(s: ^char, c: int32; p: ^char) := {\n    exists [c1: char] s -> c1 <*> c == c1 <*> p == s;\n    exists [c1: char] s -> c1 <*> c1 == '\\0' <*> c != c1 <*> p == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> strc(s + 1, c; p)\n}",
        "strcmp": "fn strcmp(s1: ^char, s2: ^char) := {\n    locals: (b: int32, ret: int32)\n    pre: strd(s1, s2; b)\n    post: ret == b\n}\n\npred strd(s1: ^char, s2: ^char; b: int32) := {\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 == c2 <*> strd(s1 + 1, s2 + 1; b)\n}",
        "strcpy": "fn strcpy(dest: ^char, src: ^char) := {\n    locals: (lst_src: list<char>, n: int32, ret: ^char)\n    pre: cstr(src; lst_src) <*> n == len(lst_src)\n    pre_mut: allocd(dest, n + 1)\n    post: cstr(dest; lst_src) <*> ret == dest\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strcspn": "fn strcspn(s1: ^char, s2: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: strcslen(s1, s2; n)\n    post: ret == n\n}\n\npred strcslen(s1: ^char, s2: ^char; n: int32) := {\n    s1 -> '\\0' <*> n == 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> n == 0 <*> hasc(s2, c; b) <*> b != 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> strcslen(s1 + 1, s2; k) <*> n == k + 1 <*> hasc(s2, c; b) <*> b == 0\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strdup": "fn strdup(str: ^char) := {\n    locals: (lst_src: list<char>, n: int32, dest: ^char, ret: ^char)\n    pre: cstr(str; lst_src) <*> n == len(lst_src)\n    post_new: allocd(dest, n + 1)\n    post: cstr(dest; lst_src) <*> ret == dest\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strlen": "fn strlen(s: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: str(s; n)\n    post: ret == n\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k)\n}\n",
        "strncat": "fn strncat(dest: ^char, src: ^char, n: uint32) := {\n    locals: (lst_src: list<char>, lst_dest: list<char>, n1: int32, m: int32, ret: ^char)\n    pre: cstrn1(src, n; lst_src) <*> cstr(dest; lst_dest) <*> n1 == len(lst_src) <*> m == len(lst_dest)\n    pre_mut: allocd(dest + m, n1 + 1) \n    post: cstr(dest + m; lst_src) <*> ret == dest\n}\n\npred cstrn1(s: ^char, n: uint32; lst: list<char>) := {\n    exists [c: char] s -> c <*> (c == '\\0' || n <= 0) <*> lst == []; \n    exists [c: char, lst_tl: list<char>] s -> c <*> (c != '\\0' && n > 0) <*> cstrn1(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl)\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strncmp": "fn strncmp(s1: ^char, s2: ^char, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: strnd(s1, s2, n; b)\n    post: ret == b\n}\n\npred strnd(s1: ^char, s2: ^char, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 == c2 <*> strnd(s1 + 1, s2 + 1, n - 1; b)    \n}",
        "strncpy": "fn strncpy(dest: ^char, src: ^char, n: uint32) := {\n    locals: (lst_src: list<char>, ret: ^char)\n    pre: cstrn(src, n; lst_src) \n    pre_mut: allocd(dest, n)\n    post: memw(dest; lst_src) <*> ret == dest\n}\n\npred cstrn(s: ^char, n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == []; \n    exists [c: char] n > 0 <*> s -> c <*> c == '\\0' <*> zeroes(n; lst);\n    exists [c: char, lst_tl: list<char>] n > 0 <*> s -> c <*> c != '\\0' <*> cstrn(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl)\n}\n\npred zeroes(n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] n > 0 <*> c == '\\0' <*> lst == cons(c, lst_tl) <*> zeroes(n - 1; lst_tl)\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strndup": "fn strndup(str: ^char, n: uint32) := {\n    locals: (lst_src: list<char>, n1: int32, dest: ^char, ret: ^char)\n    pre: cstrn1(str, n; lst_src) <*> n1 == len(lst_src)\n    post_new: allocd(dest, n1 + 1)\n    post: cstr(dest; lst_src) <*> ret == dest\n}\n\npred cstrn1(s: ^char, n: uint32; lst: list<char>) := {\n    exists [c: char] s -> c <*> (c == '\\0' || n <= 0) <*> lst == []; \n    exists [c: char, lst_tl: list<char>] s -> c <*> (c != '\\0' && n > 0) <*> cstrn1(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl)\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strpbrk": "fn strpbrk(s1: ^char, s2: ^char) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strcs(s1, s2; p)\n    post: ret == p\n}\n\npred strcs(s1: ^char, s2: ^char; p: ^char) := {\n    s1 -> '\\0' <*> p == 0;\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> strcs(s1 + 1, s2; p) <*> hasc(s2, c; b) <*> b == 0;\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> p == s1 <*> hasc(s2, c; b) <*> b != 0\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strrchr": "fn strrchr(s: ^char, c: int32) := {\n    locals: (n: int32, ret: ^char)\n    pre: str(s; n) <*> c == 0\n    post: ret == s + n;\n\n    locals: (n: int32, ret: ^char)\n    pre: str(s; n) <*> n <= 0 <*> c != 0\n    post: ret == 0;\n\n    locals: (p: ^char, n: int32, ret: ^char)\n    pre: str(s; n) <*> n > 0 <*> c != 0 <*> strrc(s, c, n - 1; p)\n    post: ret == p\n}\n\npred strrc(s: ^char, c: int32, n: int32; p: ^char) := {\n    exists [c1: char] s + n -> c1 <*> c1 == c <*> p == s + n; \n    exists [c1: char] s + n -> c1 <*> c1 != c <*> n <= 0 <*> p == 0; \n    exists [c1: char] s + n -> c1 <*> c1 != c <*> n > 0 <*> strrc(s, c, n - 1; p)\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k)\n}",
        "strspn": "fn strspn(s1: ^char, s2: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: strslen(s1, s2; n)\n    post: ret == n\n}\n\npred strslen(s1: ^char, s2: ^char; n: int32) := {\n    s1 -> '\\0' <*> n == 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> n == 0 <*> hasc(s2, c; b) <*> b == 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> strslen(s1 + 1, s2; k) <*> n == k + 1 <*> hasc(s2, c; b) <*> b != 0\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strstr": "fn strstr(s1: ^char, s2: ^char) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strfind(s1, s2; p)\n    post: ret == p\n}\n\npred strfind(s1: ^char, s2: ^char; p: ^char) := {\n    s1 -> '\\0' <*> s2 -> '\\0' <*> p == s1;\n    exists [c: char] s1 -> '\\0' <*> s2 -> c <*> c != '\\0' <*> p == 0;\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> strfind(s1 + 1, s2; p) <*> strd2(s1, s2; b) <*> b != 0;\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> p == s1 <*> strd2(s1, s2; b) <*> b == 0\n}\n\npred strd2(s1: ^char, s2: ^char; b: int32) := {\n    s2 -> '\\0' <*> b == 0;\n    exists [c1: char, c2: char] s1 -> c1 <*> s2 -> c2 <*> c2 != '\\0' <*> (c1 != c2 || c1 == '\\0') <*> b == -1;\n    exists [c1: char, c2: char] s1 -> c1 <*> s2 -> c2 <*> c2 != '\\0' <*> (c1 == c2 && c1 != '\\0') <*> strd2(s1 + 1, s2 + 1; b)\n}",
        "tolower": "fn tolower(c: int32) := {\n    locals: (c1: int32, ret: int32)\n    pre: tolower(c; c1)\n    post: ret == c1\n}\n\npred tolower(c: int32; c1: int32) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A');\n    (c < 'A' || c > 'Z') <*> c1 == c\n}",
        "toupper": "fn toupper(c: int32) := {\n    locals: (c1: int32, ret: int32)\n    pre: toupper(c; c1)\n    post: ret == c1\n}\n\npred toupper(c: int32; c1: int32) := {\n    (c >= 'a' && c <= 'z') <*> c1 == c + ('A' - 'a');\n    (c < 'a' || c > 'z') <*> c1 == c\n}"
    },
    "over": {
        "abs": "fn abs(x: int32) := {\n    locals: (y: int32, ret: int32)\n    pre: pabs(x; y)\n    post: ret == y\n}\n\npred pabs(x: int32; y: int32) := {\n    x >= 0 <*> y == x <*> (y == x || y == -x);\n    x < 0 <*> y == -x <*> (y == x || y == -x)\n}",
        "atof": "fn atof(s: ^char) := {\n    locals: (n: int32, i: float64, ret: float64)\n    pre: strf(s; n)\n    post: ret == i <*> i <= 10 ** n <*> i >= -10 ** (n - 1)\n}\n\npred strf(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0 <*> n >= 0;\n    exists [c: char] s -> c <*> c != '\\0' <*> c == '.' <*> n == 0 <*> n >= 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> c != '.' <*> strf(s + 1; k) <*> n == k + 1 <*> n >= 0\n}",
        "atoi": "fn atoi(s: ^char) := {\n    locals: (n: int32, i: int32, ret: int32)\n    pre: str(s; n)\n    post: ret == i <*> i <= 10 ** n <*> i >= -10 ** (n - 1)\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0 <*> n >= 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k) <*> n >= 0\n}",
        "atol": "fn atol(s: ^char) := {\n    locals: (n: int32, i: int64, ret: int64)\n    pre: str(s; n)\n    post: ret == i <*> i <= 10 ** n <*> i >= -10 ** (n - 1)\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0 <*> n >= 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k) <*> n >= 0\n}",
        "getchar": "fn getchar() := {\n    locals: (c: char, ret: char)\n    pre: emp\n    post: ret == c\n}",
        "isalnum": "fn isalnum(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isalnum(c; b)\n    post: ret == b\n}\n\npred isalnum(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 == 0 && b2 == 0) <*> b == 0;\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 != 0 || b2 != 0) <*> b == 1\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isalpha": "fn isalpha(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isalpha(c; b)\n    post: ret == b\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}",
        "iscntrl": "fn iscntrl(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: iscntrl(c; b)\n    post: ret == b\n}\n\npred iscntrl(c: int32; b: int32) := {\n    (c == 127 || (c >= 0 && c <= 31)) <*> b == 1;\n    (c != 127 && (c < 0 || c > 31)) <*> b == 0\n}",
        "isdigit": "fn isdigit(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isdigit(c; b)\n    post: ret == b\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isgraph": "fn isgraph(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isgraph(c; b)\n    post: ret == b\n}\n\npred isgraph(c: int32; b: int32) := {\n    exists [b1: int32] isprint(c; b1) <*> (b1 == 0 || c == ' ') <*> b == 0;\n    exists [b1: int32] isprint(c; b1) <*> (b1 != 0 && c != ' ') <*> b == 1\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}",
        "islower": "fn islower(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: islower(c; b)\n    post: ret == b\n}\n\npred islower(c: int32; b: int32) := {\n    (c >= 'a' && c <= 'z') <*> b == 1;\n    (c < 'a' || c > 'z') <*> b == 0\n}",
        "isprint": "fn isprint(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isprint(c; b)\n    post: ret == b\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}",
        "ispunct": "fn ispunct(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: ispunct(c; b)\n    post: ret == b\n}\n\npred ispunct(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32, b3: int32] isprint(c; b1) <*> isspace(c; b2) <*> isalnum(c; b3) <*> (b1 != 0 && b2 == 0 && b3 == 0) <*> b == 1;\n    exists [b1: int32, b2: int32, b3: int32] isprint(c; b1) <*> isspace(c; b2) <*> isalnum(c; b3) <*> (b1 == 0 || b2 != 0 || b3 != 0) <*> b == 0\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}\n\npred isspace(c: int32; b: int32) := {\n    (c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r' || c == ' ') <*> b == 1;\n    (c != '\\t' && c != '\\n' && c != '\\v' && c != '\\f' && c != '\\r' && c != ' ') <*> b == 0\n}\n\npred isalnum(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 == 0 && b2 == 0) <*> b == 0;\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 != 0 || b2 != 0) <*> b == 1\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isspace": "fn isspace(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isspace(c; b)\n    post: ret == b\n}\n\npred isspace(c: int32; b: int32) := {\n    (c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r' || c == ' ') <*> b == 1;\n    (c != '\\t' && c != '\\n' && c != '\\v' && c != '\\f' && c != '\\r' && c != ' ') <*> b == 0\n}",
        "isupper": "fn isupper(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isupper(c; b)\n    post: ret == b\n}\n\npred isupper(c: int32; b: int32) := {\n    (c >= 'A' && c <= 'Z') <*> b == 1;\n    (c < 'A' || c > 'Z') <*> b == 0\n}",
        "isxdigit": "fn isxdigit(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isxdigit(c; b)\n    post: ret == b\n}\n\npred isxdigit(c: int32; b: int32) := {\n    exists [b1: int32] isdigit(c; b1) <*> (b1 != 0 || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) <*> b == 1;\n    exists [b1: int32] isdigit(c; b1) <*> (b1 == 0 && (c < 'a' || c > 'f') && (c < 'A' || c > 'F')) <*> b == 0\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "memchr": "fn memchr(s: ^T, c: int32, n: uint32) := {\n    locals: (p: ^char, ret: ^T)\n    pre: memcover(s, s, c, n; p)\n    post: ret == p\n}\n\npred memcover(s: ^T, s1: ^T, c: int32, n: uint32; p: ^T) := {\n    n == 0 <*> p == 0 <*> (p == 0 || p >= s1);\n    exists [c1: char] s -> c1 <*> n != 0 <*> c == c1 <*> p == s <*> (p == 0 || p >= s1);\n    exists [c1: char] s -> c1 <*> n != 0 <*> c != c1 <*> memcover(s + 1, s1, c, n - 1; p) <*> (p == 0 || p >= s1)\n}",
        "memcmp": "fn memcmp(s1: ^T, s2: ^T, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: memd(s1, s2, n; b)\n    post: ret == b\n}\n\npred memd(s1: ^T, s2: ^T, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> c1 == c2 <*> memd(s1 + 1, s2 + 1, n - 1; b)\n}",
        "putchar": "fn putchar(c: int32) := {\n    locals: (ret: int32)\n    pre: emp\n    post: ret == c\n}",
        "puts": "fn puts(s: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: str(s; n)\n    post: ret == n + 1\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0 <*> n >= 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k) <*> n >= 0\n}",
        "rand": "fn rand() := {\n    locals: (n: int32, ret: int32)\n    pre: emp\n    post: ret == n <*> n >= 0\n}",
        "strcasecmp": "fn strcasecmp(s1: ^char, s2: ^char) := {\n    locals: (b: int32, ret: int32)\n    pre: strcased(s1, s2; b)\n    post: ret == b\n}\n\npred strcased(s1: ^char, s2: ^char; b: int32) := {\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 != c4 <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 == c4 <*> strcased(s1 + 1, s2 + 1; b)\n}\n\npred tolower(c: char; c1: char) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A') <*> (c1 == c || c1 == c + ('a' - 'A'));\n    (c < 'A' || c > 'Z') <*> c1 == c <*> (c1 == c || c1 == c + ('a' - 'A'))\n}",
        "strcasencmp": "fn strcasencmp(s1: ^char, s2: ^char, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: strcasend(s1, s2, n; b)\n    post: ret == b\n}\n\npred strcasend(s1: ^char, s2: ^char, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 != c4 <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 == c4 <*> strcasend(s1 + 1, s2 + 1, n - 1; b)\n}\n\npred tolower(c: char; c1: char) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A') <*> (c1 == c || c1 == c + ('a' - 'A'));\n    (c < 'A' || c > 'Z') <*> c1 == c <*> (c1 == c || c1 == c + ('a' - 'A'))\n}",
        "strchr": "fn strchr(s: ^char, c: int32) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strcover(s, s, c; p)\n    post: ret == p\n}\n\npred strcover(s: ^char, s1: ^char, c: int32; p: ^char) := {\n    exists [c1: char] s -> c1 <*> c == c1 <*> p == s <*> (p == 0 || p >= s1);\n    exists [c1: char] s -> c1 <*> c1 == '\\0' <*> c != c1 <*> p == 0 <*> (p == 0 || p >= s1);\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> strcover(s + 1, s1, c; p) <*> (p == 0 || p >= s1)\n}",
        "strcmp": "fn strcmp(s1: ^char, s2: ^char) := {\n    locals: (b: int32, ret: int32)\n    pre: strd(s1, s2; b)\n    post: ret == b\n}\n\npred strd(s1: ^char, s2: ^char; b: int32) := {\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 == c2 <*> strd(s1 + 1, s2 + 1; b)\n}",
        "strcspn": "fn strcspn(s1: ^char, s2: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: strcslen(s1, s2; n)\n    post: ret == n\n}\n\npred strcslen(s1: ^char, s2: ^char; n: int32) := {\n    s1 -> '\\0' <*> n == 0 <*> n >= 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> n == 0 <*> hasc(s2, c; b) <*> b != 0 <*> n >= 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> strcslen(s1 + 1, s2; k) <*> n == k + 1 <*> hasc(s2, c; b) <*> b == 0 <*> n >= 0\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strlen": "fn strlen(s: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: str(s; n)\n    post: ret == n\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0 <*> n >= 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k) <*> n >= 0\n}",
        "strncmp": "fn strncmp(s1: ^char, s2: ^char, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: strnd(s1, s2, n; b)\n    post: ret == b\n}\n\npred strnd(s1: ^char, s2: ^char, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 == c2 <*> strnd(s1 + 1, s2 + 1, n - 1; b)    \n}",
        "strpbrk": "fn strpbrk(s1: ^char, s2: ^char) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strcsover(s1, s1, s2; p)\n    post: ret == p\n}\n\npred strcsover(s1: ^char, s11: ^char, s2: ^char; p: ^char) := {\n    s1 -> '\\0' <*> p == 0 <*> (p == 0 || p >= s11);\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> strcsover(s1 + 1, s11, s2; p) <*> hasc(s2, c; b) <*> b == 0 <*> (p == 0 || p >= s11);\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> p == s1 <*> hasc(s2, c; b) <*> b != 0 <*> (p == 0 || p >= s11)\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strrchr": "fn strrchr(s: ^char, c: int32) := {\n    locals: (n: int32, ret: ^char)\n    pre: str(s; n) <*> c == 0\n    post: ret == s + n;\n\n    locals: (n: int32, ret: ^char)\n    pre: str(s; n) <*> n <= 0 <*> c != 0\n    post: ret == 0;\n\n    locals: (p: ^char, n: int32, ret: ^char)\n    pre: str(s; n) <*> n > 0 <*> c != 0 <*> strrc(s, c, n - 1; p)\n    post: ret == p\n}\n\npred strrc(s: ^char, c: int32, n: int32; p: ^char) := {\n    exists [c1: char] s + n -> c1 <*> c1 == c <*> p == s + n <*> (p == 0 || p >= s); \n    exists [c1: char] s + n -> c1 <*> c1 != c <*> n <= 0 <*> p == 0 <*> (p == 0 || p >= s); \n    exists [c1: char] s + n -> c1 <*> c1 != c <*> n > 0 <*> strrc(s, c, n - 1; p) <*> (p == 0 || p >= s)\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0 <*> n >= 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k) <*> n >= 0\n}",
        "strspn": "fn strspn(s1: ^char, s2: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: strslen(s1, s2; n)\n    post: ret == n\n}\n\npred strslen(s1: ^char, s2: ^char; n: int32) := {\n    s1 -> '\\0' <*> n == 0 <*> n >= 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> n == 0 <*> hasc(s2, c; b) <*> b == 0 <*> n >= 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> strslen(s1 + 1, s2; k) <*> n == k + 1 <*> hasc(s2, c; b) <*> b != 0 <*> n >= 0\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strstr": "fn strstr(s1: ^char, s2: ^char) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strfindover(s1, s1, s2; p)\n    post: ret == p\n}\n\npred strfindover(s1: ^char, s11: ^char, s2: ^char; p: ^char) := {\n    s1 -> '\\0' <*> s2 -> '\\0' <*> p == s1 <*> (p == 0 || p >= s11);\n    exists [c: char] s1 -> '\\0' <*> s2 -> c <*> c != '\\0' <*> p == 0 <*> (p == 0 || p >= s11);\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> strfindover(s1 + 1, s11, s2; p) <*> strd2(s1, s2; b) <*> b != 0 <*> (p == 0 || p >= s11);\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> p == s1 <*> strd2(s1, s2; b) <*> b == 0 <*> (p == 0 || p >= s11)\n}\n\npred strd2(s1: ^char, s2: ^char; b: int32) := {\n    s2 -> '\\0' <*> b == 0;\n    exists [c1: char, c2: char] s1 -> c1 <*> s2 -> c2 <*> c2 != '\\0' <*> (c1 != c2 || c1 == '\\0') <*> b == -1;\n    exists [c1: char, c2: char] s1 -> c1 <*> s2 -> c2 <*> c2 != '\\0' <*> (c1 == c2 && c1 != '\\0') <*> strd2(s1 + 1, s2 + 1; b)\n}",
        "tolower": "fn tolower(c: int32) := {\n    locals: (c1: int32, ret: int32)\n    pre: tolower(c; c1)\n    post: ret == c1\n}\n\npred tolower(c: int32; c1: int32) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A') <*> (c1 == c || c1 == c + ('a' - 'A'));\n    (c < 'A' || c > 'Z') <*> c1 == c <*> (c1 == c || c1 == c + ('a' - 'A'))\n}",
        "toupper": "fn toupper(c: int32) := {\n    locals: (c1: int32, ret: int32)\n    pre: toupper(c; c1)\n    post: ret == c1\n}\n\npred toupper(c: int32; c1: int32) := {\n    (c >= 'a' && c <= 'z') <*> c1 == c + ('A' - 'a') <*> (c1 == c || c1 == c + ('A' - 'a'));\n    (c < 'a' || c > 'z') <*> c1 == c <*> (c1 == c || c1 == c + ('A' - 'a'))\n}"
    },
    "exact": {
        "abs": "fn abs(x: int32) := {\n    locals: (ret: int32)\n    pre: x < 0\n    post: ret == -x;\n\n    locals: (ret: int32)\n    pre: x >= 0\n    post: ret == x\n}",
        "bzero": "fn bzero(s: ^T, n: uint32) := {\n    locals: (lst: list<char>)\n    pre: zeroes(n; lst)\n    pre_mut: allocd(s, n) \n    post: memw(s; lst)\n}\n\npred zeroes(n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] n > 0 <*> c == '\\0' <*> lst == cons(c, lst_tl) <*> zeroes(n - 1; lst_tl)\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "calloc": "fn calloc(nitems: uint32, size: uint32) := {\n    locals: (lst: list<char>, retval: ^T, ret: ^T)\n    pre: zeroes(nitems * size; lst)\n    post_new: allocd(retval, nitems * size)\n    post: memw(retval; lst) <*> ret == retval\n}\n\npred zeroes(n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] n > 0 <*> c == '\\0' <*> lst == cons(c, lst_tl) <*> zeroes(n - 1; lst_tl)\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "free": "fn free(src: ^T) := {\n    locals: (n: int32)\n    pre: nallocd(src; n)\n    pre_vanish: allocd(src, n)\n    post: emp\n}",
        "isalnum": "fn isalnum(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isalnum(c; b)\n    post: ret == b\n}\n\npred isalnum(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 == 0 && b2 == 0) <*> b == 0;\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 != 0 || b2 != 0) <*> b == 1\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isalpha": "fn isalpha(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isalpha(c; b)\n    post: ret == b\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}",
        "iscntrl": "fn iscntrl(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: iscntrl(c; b)\n    post: ret == b\n}\n\npred iscntrl(c: int32; b: int32) := {\n    (c == 127 || (c >= 0 && c <= 31)) <*> b == 1;\n    (c != 127 && (c < 0 || c > 31)) <*> b == 0\n}",
        "isdigit": "fn isdigit(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isdigit(c; b)\n    post: ret == b\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isgraph": "fn isgraph(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isgraph(c; b)\n    post: ret == b\n}\n\npred isgraph(c: int32; b: int32) := {\n    exists [b1: int32] isprint(c; b1) <*> (b1 == 0 || c == ' ') <*> b == 0;\n    exists [b1: int32] isprint(c; b1) <*> (b1 != 0 && c != ' ') <*> b == 1\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}",
        "islower": "fn islower(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: islower(c; b)\n    post: ret == b\n}\n\npred islower(c: int32; b: int32) := {\n    (c >= 'a' && c <= 'z') <*> b == 1;\n    (c < 'a' || c > 'z') <*> b == 0\n}",
        "isprint": "fn isprint(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isprint(c; b)\n    post: ret == b\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}",
        "ispunct": "fn ispunct(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: ispunct(c; b)\n    post: ret == b\n}\n\npred ispunct(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32, b3: int32] isprint(c; b1) <*> isspace(c; b2) <*> isalnum(c; b3) <*> (b1 != 0 && b2 == 0 && b3 == 0) <*> b == 1;\n    exists [b1: int32, b2: int32, b3: int32] isprint(c; b1) <*> isspace(c; b2) <*> isalnum(c; b3) <*> (b1 == 0 || b2 != 0 || b3 != 0) <*> b == 0\n}\n\npred isprint(c: int32; b: int32) := {\n    (c < 32 || c > 126) <*> b == 0;\n    (c >= 32 && c <= 126) <*> b == 1\n}\n\npred isspace(c: int32; b: int32) := {\n    (c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r' || c == ' ') <*> b == 1;\n    (c != '\\t' && c != '\\n' && c != '\\v' && c != '\\f' && c != '\\r' && c != ' ') <*> b == 0\n}\n\npred isalnum(c: int32; b: int32) := {\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 == 0 && b2 == 0) <*> b == 0;\n    exists [b1: int32, b2: int32] isalpha(c; b1) <*> isdigit(c; b2) <*> (b1 != 0 || b2 != 0) <*> b == 1\n}\n\npred isalpha(c: int32; b: int32) := {\n    ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z')) <*> b == 0;\n    ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) <*> b == 1\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "isspace": "fn isspace(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isspace(c; b)\n    post: ret == b\n}\n\npred isspace(c: int32; b: int32) := {\n    (c == '\\t' || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r' || c == ' ') <*> b == 1;\n    (c != '\\t' && c != '\\n' && c != '\\v' && c != '\\f' && c != '\\r' && c != ' ') <*> b == 0\n}",
        "isupper": "fn isupper(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isupper(c; b)\n    post: ret == b\n}\n\npred isupper(c: int32; b: int32) := {\n    (c >= 'A' && c <= 'Z') <*> b == 1;\n    (c < 'A' || c > 'Z') <*> b == 0\n}",
        "isxdigit": "fn isxdigit(c: int32) := {\n    locals: (b: int32, ret: int32)\n    pre: isxdigit(c; b)\n    post: ret == b\n}\n\npred isxdigit(c: int32; b: int32) := {\n    exists [b1: int32] isdigit(c; b1) <*> (b1 != 0 || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) <*> b == 1;\n    exists [b1: int32] isdigit(c; b1) <*> (b1 == 0 && (c < 'a' || c > 'f') && (c < 'A' || c > 'F')) <*> b == 0\n}\n\npred isdigit(c: int32; b: int32) := {\n    (c >= '0' && c <= '9') <*> b == 1;\n    (c < '0' || c > '9') <*> b == 0\n}",
        "malloc": "fn malloc(n: uint32) := {\n    locals: (retval: ^T, ret: ^T)\n    pre: emp\n    post_new: allocd(retval, n)\n    post: ret == retval\n}",
        "memchr": "fn memchr(s: ^T, c: int32, n: uint32) := {\n    locals: (p: ^char, ret: ^T)\n    pre: memc(s, c, n; p)\n    post: ret == p\n}\n\npred memc(s: ^T, c: int32, n: uint32; p: ^T) := {\n    n == 0 <*> p == 0;\n    exists [c1: char] s -> c1 <*> n != 0 <*> c == c1 <*> p == s;\n    exists [c1: char] s -> c1 <*> n != 0 <*> c != c1 <*> memc(s + 1, c, n - 1; p)\n}",
        "memcmp": "fn memcmp(s1: ^T, s2: ^T, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: memd(s1, s2, n; b)\n    post: ret == b\n}\n\npred memd(s1: ^T, s2: ^T, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> c1 == c2 <*> memd(s1 + 1, s2 + 1, n - 1; b)\n}",
        "memcpy": "fn memcpy(dest: ^T, src: ^T, n: uint32) := {\n    locals: (lst_src: list<char>, ret: ^T)\n    pre: memseg(src, n; lst_src) \n    pre_mut: allocd(dest, n)\n    post: memw(dest; lst_src) <*> ret == dest\n}\n\npred memseg(s: ^char, n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memseg(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != [] <*> n > 0\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "memmove": "fn memmove(dest: ^T, src: ^T, n: uint32) := {\n    locals: (lst_src: list<char>, ret: ^T)\n    pre: memseg(src, n; lst_src) \n    pre_mut: allocd(dest, n)\n    post: memw(dest; lst_src) <*> ret == dest\n}\n\npred memseg(s: ^char, n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memseg(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != [] <*> n > 0\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "memset": "fn memset(str: ^T, c: int32, n: uint32) := {\n    locals: (lst: list<char>, ret: ^T)\n    pre: nbytes(c, n; lst)\n    pre_mut: allocd(str, n) \n    post: memw(str; lst) <*> ret == str\n}\n\npred nbytes(c: char, n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [lst_tl: list<char>] n > 0 <*> lst == cons(c, lst_tl) <*> nbytes(c, n - 1; lst_tl)\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "putchar": "fn putchar(c: int32) := {\n    locals: (ret: int32)\n    pre: emp\n    post: ret == c\n}",
        "puts": "fn puts(s: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: str(s; n)\n    post: ret == n + 1\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k)\n}",
        "strcasecmp": "fn strcasecmp(s1: ^char, s2: ^char) := {\n    locals: (b: int32, ret: int32)\n    pre: strcased(s1, s2; b)\n    post: ret == b\n}\n\npred strcased(s1: ^char, s2: ^char; b: int32) := {\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 != c4 <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 == c4 <*> strcased(s1 + 1, s2 + 1; b)\n}\n\npred tolower(c: char; c1: char) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A');\n    (c < 'A' || c > 'Z') <*> c1 == c\n}",
        "strcasencmp": "fn strcasencmp(s1: ^char, s2: ^char, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: strcasend(s1, s2, n; b)\n    post: ret == b\n}\n\npred strcasend(s1: ^char, s2: ^char, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 != c4 <*> b == c3 - c4;\n    exists [c1: uchar, c2: uchar, c3: uchar, c4: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> tolower(c1; c3) <*> tolower(c2; c4) <*> c3 == c4 <*> strcasend(s1 + 1, s2 + 1, n - 1; b)\n}\n\npred tolower(c: char; c1: char) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A');\n    (c < 'A' || c > 'Z') <*> c1 == c\n}",
        "strcat": "fn strcat(dest: ^char, src: ^char) := {\n    locals: (lst_src: list<char>, lst_dest: list<char>, n: int32, m: int32, ret: ^char)\n    pre: cstr(src; lst_src) <*> cstr(dest; lst_dest) <*> n == len(lst_src) <*> m == len(lst_dest) \n    pre_mut: allocd(dest + m, n + 1) \n    post: cstr(dest + m; lst_src) <*> ret == dest\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strchr": "fn strchr(s: ^char, c: int32) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strc(s, c; p)\n    post: ret == p\n}\n\npred strc(s: ^char, c: int32; p: ^char) := {\n    exists [c1: char] s -> c1 <*> c == c1 <*> p == s;\n    exists [c1: char] s -> c1 <*> c1 == '\\0' <*> c != c1 <*> p == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> strc(s + 1, c; p)\n}",
        "strcmp": "fn strcmp(s1: ^char, s2: ^char) := {\n    locals: (b: int32, ret: int32)\n    pre: strd(s1, s2; b)\n    post: ret == b\n}\n\npred strd(s1: ^char, s2: ^char; b: int32) := {\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 == c2 <*> strd(s1 + 1, s2 + 1; b)\n}",
        "strcpy": "fn strcpy(dest: ^char, src: ^char) := {\n    locals: (lst_src: list<char>, n: int32, ret: ^char)\n    pre: cstr(src; lst_src) <*> n == len(lst_src)\n    pre_mut: allocd(dest, n + 1)\n    post: cstr(dest; lst_src) <*> ret == dest\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strcspn": "fn strcspn(s1: ^char, s2: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: strcslen(s1, s2; n)\n    post: ret == n\n}\n\npred strcslen(s1: ^char, s2: ^char; n: int32) := {\n    s1 -> '\\0' <*> n == 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> n == 0 <*> hasc(s2, c; b) <*> b != 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> strcslen(s1 + 1, s2; k) <*> n == k + 1 <*> hasc(s2, c; b) <*> b == 0\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strdup": "fn strdup(str: ^char) := {\n    locals: (lst_src: list<char>, n: int32, dest: ^char, ret: ^char)\n    pre: cstr(str; lst_src) <*> n == len(lst_src)\n    post_new: allocd(dest, n + 1)\n    post: cstr(dest; lst_src) <*> ret == dest\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strlen": "fn strlen(s: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: str(s; n)\n    post: ret == n\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k)\n}\n",
        "strncat": "fn strncat(dest: ^char, src: ^char, n: uint32) := {\n    locals: (lst_src: list<char>, lst_dest: list<char>, n1: int32, m: int32, ret: ^char)\n    pre: cstrn1(src, n; lst_src) <*> cstr(dest; lst_dest) <*> n1 == len(lst_src) <*> m == len(lst_dest)\n    pre_mut: allocd(dest + m, n1 + 1) \n    post: cstr(dest + m; lst_src) <*> ret == dest\n}\n\npred cstrn1(s: ^char, n: uint32; lst: list<char>) := {\n    exists [c: char] s -> c <*> (c == '\\0' || n <= 0) <*> lst == []; \n    exists [c: char, lst_tl: list<char>] s -> c <*> (c != '\\0' && n > 0) <*> cstrn1(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl)\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strncmp": "fn strncmp(s1: ^char, s2: ^char, n: uint32) := {\n    locals: (b: int32, ret: int32)\n    pre: strnd(s1, s2, n; b)\n    post: ret == b\n}\n\npred strnd(s1: ^char, s2: ^char, n: uint32; b: int32) := {\n    n == 0 <*> b == 0;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 == '\\0' || c2 == '\\0') <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 != c2 <*> b == c1 - c2;\n    exists [c1: uchar, c2: uchar] n != 0 <*> s1 -> c1 <*> s2 -> c2 <*> (c1 != '\\0' && c2 != '\\0') <*> c1 == c2 <*> strnd(s1 + 1, s2 + 1, n - 1; b)    \n}",
        "strncpy": "fn strncpy(dest: ^char, src: ^char, n: uint32) := {\n    locals: (lst_src: list<char>, ret: ^char)\n    pre: cstrn(src, n; lst_src) \n    pre_mut: allocd(dest, n)\n    post: memw(dest; lst_src) <*> ret == dest\n}\n\npred cstrn(s: ^char, n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == []; \n    exists [c: char] n > 0 <*> s -> c <*> c == '\\0' <*> zeroes(n; lst);\n    exists [c: char, lst_tl: list<char>] n > 0 <*> s -> c <*> c != '\\0' <*> cstrn(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl)\n}\n\npred zeroes(n: uint32; lst: list<char>) := {\n    n <= 0 <*> lst == [];\n    exists [c: char, lst_tl: list<char>] n > 0 <*> c == '\\0' <*> lst == cons(c, lst_tl) <*> zeroes(n - 1; lst_tl)\n}\n\npred memw(s: ^char; lst: list<char>) := {\n    lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> memw(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strndup": "fn strndup(str: ^char, n: uint32) := {\n    locals: (lst_src: list<char>, n1: int32, dest: ^char, ret: ^char)\n    pre: cstrn1(str, n; lst_src) <*> n1 == len(lst_src)\n    post_new: allocd(dest, n1 + 1)\n    post: cstr(dest; lst_src) <*> ret == dest\n}\n\npred cstrn1(s: ^char, n: uint32; lst: list<char>) := {\n    exists [c: char] s -> c <*> (c == '\\0' || n <= 0) <*> lst == []; \n    exists [c: char, lst_tl: list<char>] s -> c <*> (c != '\\0' && n > 0) <*> cstrn1(s + 1, n - 1; lst_tl) <*> lst == cons(c, lst_tl)\n}\n\npred cstr(s: ^char; lst: list<char>) := {\n    s -> '\\0' <*> lst == [];\n    exists [c: char, lst_tl: list<char>] s -> c <*> c != '\\0' <*> cstr(s + 1; lst_tl) <*> lst == cons(c, lst_tl) <*> lst != []\n}",
        "strpbrk": "fn strpbrk(s1: ^char, s2: ^char) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strcs(s1, s2; p)\n    post: ret == p\n}\n\npred strcs(s1: ^char, s2: ^char; p: ^char) := {\n    s1 -> '\\0' <*> p == 0;\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> strcs(s1 + 1, s2; p) <*> hasc(s2, c; b) <*> b == 0;\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> p == s1 <*> hasc(s2, c; b) <*> b != 0\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strrchr": "fn strrchr(s: ^char, c: int32) := {\n    locals: (n: int32, ret: ^char)\n    pre: str(s; n) <*> c == 0\n    post: ret == s + n;\n\n    locals: (n: int32, ret: ^char)\n    pre: str(s; n) <*> n <= 0 <*> c != 0\n    post: ret == 0;\n\n    locals: (p: ^char, n: int32, ret: ^char)\n    pre: str(s; n) <*> n > 0 <*> c != 0 <*> strrc(s, c, n - 1; p)\n    post: ret == p\n}\n\npred strrc(s: ^char, c: int32, n: int32; p: ^char) := {\n    exists [c1: char] s + n -> c1 <*> c1 == c <*> p == s + n; \n    exists [c1: char] s + n -> c1 <*> c1 != c <*> n <= 0 <*> p == 0; \n    exists [c1: char] s + n -> c1 <*> c1 != c <*> n > 0 <*> strrc(s, c, n - 1; p)\n}\n\npred str(s: ^char; n: int32) := {\n    s -> '\\0' <*> n == 0;\n    exists [c: char, k: int32] s -> c <*> c != '\\0' <*> n == k + 1 <*> str(s + 1; k)\n}",
        "strspn": "fn strspn(s1: ^char, s2: ^char) := {\n    locals: (n: int32, ret: int32)\n    pre: strslen(s1, s2; n)\n    post: ret == n\n}\n\npred strslen(s1: ^char, s2: ^char; n: int32) := {\n    s1 -> '\\0' <*> n == 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> n == 0 <*> hasc(s2, c; b) <*> b == 0;\n    exists [c: char, k: int32, b: int32] s1 -> c <*> c != '\\0' <*> strslen(s1 + 1, s2; k) <*> n == k + 1 <*> hasc(s2, c; b) <*> b != 0\n}\n\npred hasc(s: ^char, c: int32; b: int32) := {\n    s -> '\\0' <*> b == 0;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c == c1 <*> b == 1;\n    exists [c1: char] s -> c1 <*> c1 != '\\0' <*> c != c1 <*> hasc(s + 1, c; b)\n}",
        "strstr": "fn strstr(s1: ^char, s2: ^char) := {\n    locals: (p: ^char, ret: ^char)\n    pre: strfind(s1, s2; p)\n    post: ret == p\n}\n\npred strfind(s1: ^char, s2: ^char; p: ^char) := {\n    s1 -> '\\0' <*> s2 -> '\\0' <*> p == s1;\n    exists [c: char] s1 -> '\\0' <*> s2 -> c <*> c != '\\0' <*> p == 0;\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> strfind(s1 + 1, s2; p) <*> strd2(s1, s2; b) <*> b != 0;\n    exists [c: char, b: int32] s1 -> c <*> c != '\\0' <*> p == s1 <*> strd2(s1, s2; b) <*> b == 0\n}\n\npred strd2(s1: ^char, s2: ^char; b: int32) := {\n    s2 -> '\\0' <*> b == 0;\n    exists [c1: char, c2: char] s1 -> c1 <*> s2 -> c2 <*> c2 != '\\0' <*> (c1 != c2 || c1 == '\\0') <*> b == -1;\n    exists [c1: char, c2: char] s1 -> c1 <*> s2 -> c2 <*> c2 != '\\0' <*> (c1 == c2 && c1 != '\\0') <*> strd2(s1 + 1, s2 + 1; b)\n}",
        "tolower": "fn tolower(c: int32) := {\n    locals: (c1: int32, ret: int32)\n    pre: tolower(c; c1)\n    post: ret == c1\n}\n\npred tolower(c: int32; c1: int32) := {\n    (c >= 'A' && c <= 'Z') <*> c1 == c + ('a' - 'A');\n    (c < 'A' || c > 'Z') <*> c1 == c\n}",
        "toupper": "fn toupper(c: int32) := {\n    locals: (c1: int32, ret: int32)\n    pre: toupper(c; c1)\n    post: ret == c1\n}\n\npred toupper(c: int32; c1: int32) := {\n    (c >= 'a' && c <= 'z') <*> c1 == c + ('A' - 'a');\n    (c < 'a' || c > 'z') <*> c1 == c\n}"
    }
}